<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>mine-clone</title>
<style>
body { margin:0; overflow:hidden; background:#87ceeb; }
#ui {
  position:fixed; top:10px; left:10px;
  font-family: monospace; color:#fff;
  background: rgba(0,0,0,0.6);
  padding: 10px; z-index:2;
}
#overlay {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  cursor:pointer;
  z-index:1;
}
#crosshair {
  position:fixed;
  top:50%; left:50%;
  width:10px; height:10px;
  margin-left:-5px; margin-top:-5px;
  pointer-events:none;
  z-index:3;
}
#crosshair:before,#crosshair:after {
  content:'';
  position:absolute;
  background:white;
}
#crosshair:before { left:50%; top:0; width:2px; height:100%; margin-left:-1px; }
#crosshair:after { top:50%; left:0; width:100%; height:2px; margin-top:-1px; }
</style>
</head>
<body>
<div id="ui">
Click to play<br>
WASD move | Space jump | Mouse look<br>
Left Click = Break | Right Click = Place
</div>
<div id="overlay"></div>
<div id="crosshair"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
// ===== SCENE =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun = new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(50,100,50);
scene.add(sun);

window.addEventListener("resize",()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

// ===== MATERIALS =====
const geo = new THREE.BoxGeometry(1,1,1);

const mats = {
  grass:[ new THREE.MeshLambertMaterial({color:0x6dbf4b}) ],
  wood:[ new THREE.MeshLambertMaterial({color:0x8b4513}) ],
  leaves:[ new THREE.MeshLambertMaterial({color:0x00aa00}) ]
};

// ===== WORLD =====
const world = new Map();
const key = (x,y,z)=>`${x},${y},${z}`;

function addBlock(x,y,z,mat){
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x+0.5,y+0.5,z+0.5);
  scene.add(m);
  world.set(key(x,y,z), m);
  return m;
}

// ===== TERRAIN =====
const SIZE=20;
const BASE_HEIGHT=0;

for(let x=-SIZE;x<=SIZE;x++){
  for(let z=-SIZE;z<=SIZE;z++){
    // flat base
    addBlock(x,BASE_HEIGHT-1,z,mats.grass[0]);
    // small hills
    const hillHeight = Math.floor(Math.sin(x/4)*2 + Math.cos(z/4)*2 + Math.random()*1);
    for(let y=BASE_HEIGHT;y<=BASE_HEIGHT+hillHeight;y++){
      addBlock(x,y,z,mats.grass[0]);
    }
  }
}

// ===== TREES =====
function placeTree(x,z){
  // find ground
  let groundY = BASE_HEIGHT;
  for(let y=SIZE;y>=-10;y--){
    if(world.has(key(x,y,z))){ groundY=y; break; }
  }
  const h = 3+Math.floor(Math.random()*2);
  for(let ty=1;ty<=h;ty++) addBlock(x,groundY+ty,z,mats.wood[0]);
  for(let lx=-1;lx<=1;lx++)
    for(let ly=0;ly<=2;ly++)
      for(let lz=-1;lz<=1;lz++)
        if(Math.abs(lx)+Math.abs(ly)+Math.abs(lz)<=3)
          addBlock(x+lx,groundY+h+ly,z+lz,mats.leaves[0]);
}

for(let i=0;i<25;i++){
  const x=Math.floor(Math.random()*40)-20;
  const z=Math.floor(Math.random()*40)-20;
  placeTree(x,z);
}

// ===== PLAYER =====
const PLAYER_HEIGHT=2, PLAYER_RADIUS=0.35, EYE_HEIGHT=1.6, GRAVITY=0.02, SPEED=0.1, JUMP=0.35;
const player = { pos:new THREE.Vector3(0,5,0), vel:new THREE.Vector3(), onGround:false };

// ===== INPUT =====
let yaw=0,pitch=0,locked=false;
const keys={};
const overlay=document.getElementById("overlay");
const ui=document.getElementById("ui");
overlay.addEventListener("click",()=>renderer.domElement.requestPointerLock());
document.addEventListener("pointerlockchange",()=>{locked=document.pointerLockElement===renderer.domElement; ui.style.display=locked?"none":"block";});
document.addEventListener("mousemove", e=>{ if(!locked)return; yaw-=e.movementX*0.002; pitch=Math.max(-1.5, Math.min(1.5, pitch-e.movementY*0.002)); });
document.addEventListener("keydown", e=>keys[e.code]=true);
document.addEventListener("keyup", e=>keys[e.code]=false);

// ===== COLLISION =====
function collidesAt(x,y,z){
  const minX=Math.floor(x-PLAYER_RADIUS);
  const maxX=Math.floor(x+PLAYER_RADIUS);
  const minY=Math.floor(y);
  const maxY=Math.floor(y+PLAYER_HEIGHT);
  const minZ=Math.floor(z-PLAYER_RADIUS);
  const maxZ=Math.floor(z+PLAYER_RADIUS);
  for(let X=minX;X<=maxX;X++)
    for(let Y=minY;Y<=maxY;Y++)
      for(let Z=minZ;Z<=maxZ;Z++)
        if(world.has(key(X,Y,Z))) return true;
  return false;
}

// ===== BLOCK INTERACTION =====
const ray=new THREE.Raycaster();
document.addEventListener("mousedown", e=>{
  if(!locked) return;
  ray.setFromCamera({x:0,y:0}, camera);
  const hit = ray.intersectObjects(Array.from(world.values()))[0];
  if(!hit) return;
  const hx=Math.floor(hit.object.position.x-0.5);
  const hy=Math.floor(hit.object.position.y-0.5);
  const hz=Math.floor(hit.object.position.z-0.5);
  if(e.button===0){ scene.remove(hit.object); world.delete(key(hx,hy,hz)); }
  if(e.button===2){
    const nx=hx+hit.face.normal.x;
    const ny=hy+hit.face.normal.y;
    const nz=hz+hit.face.normal.z;
    if(!collidesAt(nx+0.5,ny,nz+0.5)) addBlock(nx,ny,nz,mats.grass[0]);
  }
});
document.addEventListener("contextmenu", e=>e.preventDefault());

// ===== GAME LOOP =====
function loop(){
  requestAnimationFrame(loop);
  camera.rotation.order="YXZ";
  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  const dir=new THREE.Vector3();
  if(keys.KeyW) dir.z--;
  if(keys.KeyS) dir.z++;
  if(keys.KeyA) dir.x--;
  if(keys.KeyD) dir.x++;
  dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0),yaw);

  player.vel.x=dir.x*SPEED;
  player.vel.z=dir.z*SPEED;
  player.vel.y-=GRAVITY;

  if(player.onGround && keys.Space){ player.vel.y=JUMP; player.onGround=false; }

  let ny=player.pos.y+player.vel.y;
  if(collidesAt(player.pos.x,ny,player.pos.z)){
    if(player.vel.y<0){ player.onGround=true; player.pos.y=Math.floor(player.pos.y+0.001); }
    player.vel.y=0;
  } else player.pos.y=ny, player.onGround=false;

  let nx=player.pos.x+player.vel.x;
  if(!collidesAt(nx,player.pos.y,player.pos.z)) player.pos.x=nx;
  let nz=player.pos.z+player.vel.z;
  if(!collidesAt(player.pos.x,player.pos.y,nz)) player.pos.z=nz;

  camera.position.set(player.pos.x,player.pos.y+EYE_HEIGHT,player.pos.z);

  renderer.render(scene,camera);
}
loop();
</script>
</body>
</html>

